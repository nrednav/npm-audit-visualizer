#!/usr/bin/env node

import { fileURLToPath } from "node:url";
import chalk from "chalk";
import * as Either from "fp-ts/lib/Either.js";
import * as TaskEither from "fp-ts/lib/TaskEither.js";
import { pipe } from "fp-ts/lib/function.js";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { exportParsedAuditReport } from "./modules/AuditReport/Exporter/index.js";
import { importAuditReport } from "./modules/AuditReport/Importer/index.js";
import { parseAuditReport } from "./modules/AuditReport/Parser/index.js";
import { validateAuditReport } from "./modules/AuditReport/Validator/index.js";
import { visualizeAuditReport } from "./modules/AuditReport/Visualizer/index.js";
import { PACKAGE_ENTRY_POINT, PACKAGE_NAME } from "./shared/constants.js";
import { AppError } from "./shared/errors.js";
import { logger } from "./shared/modules/logger.js";

const __filename = fileURLToPath(import.meta.url);

export const main = () => {
  logger.info(chalk.green("npm-audit-visualizer"));

  const args = yargs(hideBin(process.argv))
    .options({
      file: {
        type: "string",
        describe:
          'Path to file containing the report generated by "npm audit --json"',
        alias: "f",
        demandOption: true,
      },
      debug: {
        type: "boolean",
        describe: "Runs the app in debug mode with verbose logging",
        alias: "d",
        default: false,
      },
      port: {
        type: "number",
        describe: "Port number on which the web app should be hosted",
        alias: "p",
        default: 1248,
      },
      "export-only": {
        type: "boolean",
        describe: "Only exports the parsed audit report. Does not visualize it",
        alias: "e",
        default: false,
        hidden: true,
      },
    })
    .help()
    .alias("help", "h")
    .parseSync();

  if (args.debug) {
    logger.enableDebugMode();
  }

  if (args.file) {
    logger.info(`Audit report file: ${chalk.blueBright(args.file)}`);

    const run = pipe(
      args.file,
      importAuditReport,
      Either.flatMap(validateAuditReport),
      Either.map(parseAuditReport),
      Either.flatMap(exportParsedAuditReport()),
      TaskEither.fromEither,
      args.exportOnly
        ? TaskEither.asUnit
        : TaskEither.flatMap(visualizeAuditReport(args.port)),
      TaskEither.match(handleError(args.debug), () => {}),
    );

    run();
  }
};

const handleError = (isDebugMode: boolean) => (error: AppError) => {
  logger.error(isDebugMode ? error : error.message);
};

if (
  __filename === process.argv[1] ||
  process.argv[1]?.endsWith(PACKAGE_NAME) ||
  process.argv[1]?.endsWith(PACKAGE_ENTRY_POINT.relative)
) {
  main();

  process.on("SIGINT", () => {
    logger.info("\nExiting.");
    process.exit(0);
  });
}
